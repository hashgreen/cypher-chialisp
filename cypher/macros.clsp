(
  (defmacro @cypher.macros.assert args
    ;; Assert a series of statements.
    ;
    ; Usage: (assert cond1 cond2 ...)
    ; Taken from chia/wallet/puzzles/cat.clvm.

    (if (r args)
      (qq (if (unquote (f args))
        (unquote (c @cypher.macros.assert (r args)))
        (x)
      ))
      (f args)
    )
  )

  ;; this is very clever
  ;; I wonder if it makes sense to have "profiles" like rust does, so we can get debug messages
  ;; back from asserts in DEBUG mode, but have them stripped out for RELEASE mode
  (defmacro @cypher.macros.assert@debug args
    ;; Assert a series of statements with debugging message.
    ;
    ; Usage: (assert cond1 cond2 ...)
    ; Taken from chia/wallet/puzzles/cat.clvm.

    (if (r args)
      (qq (if (unquote (f args))
        (unquote (c @cypher.macros.assert (r args)))
        (x
          "@cypher.macros.assert failed: "
          (q . (unquote (f args)))
          "evaluates to false, leaving assertion body"
          (q . (unquote (r args)))
        )
      ))
      (f args)
    )
  )

  (defmacro @cypher.macros.and args
    ;; And a series of statements.
    ;
    ; Usage: (and cond1 cond2 ...)
    ; Taken from chia/wallet/puzzles/cat.clvm.

    (if (r args)
      (qq (if (unquote (f args))
        (unquote (c @cypher.macros.and (r args)))
        0
      ))
      (f args)
    )
  )

  (defmacro @cypher.macros.and@v2 args
    ;; And a series of statements. Alternatative implementation.
    ;
    ; Usage: (and cond1 cond2 ...)
    ; Taken from chia/wallet/puzzles/utility_macros.clib.
    ;; the other one is probably better as it terminates on the last condition rather
    ;; than exposing a lone `1`
    ;; the only advantage this one has is it doesn't choke on the (rather useless) `(and)`
    ;; case. It could be written to support it, and then this `v2` version deprecated.

    (if args
      (qq (if (unquote (f args))
        (unquote (c @cypher.macros.and@v2 (r args)))
        ()
      ))
      1
    )
   )

  (defmacro @cypher.macros.concat args
    ;; Concatenate statements.
    ;
    ; Usage: (concat stmt1 stmt2 ...)
    ;
    ; Note that this is different from `list` as there is not a `()` in the end.
    ; This function is particularly useful when concatenating atoms to an existing list.

    ;; this is a good idea. I do note that I consider `concat` to be a function that
    ;; operates on two lists, flattening them into one. Maybe a good name for this
    ;; is `prelist` (a portmanteau of "prefix list").
    ;; So `(prelist A B C)` => `(c A (c B C))`
    ;; Another good thing about `prelist` is I've never seen it before, so it doesn't have
    ;; any preconceived notions.
    ;; Another option is `multicons` or `mcons` (for "multiple cons")
    ;; ChatGPT doesn't seem to be aware of an existing library function that does this in
    ;; lisp nor scheme (although its confusion about `list*` suggests it's not a total
    ;; lisp wizard)

    (if (r args)
      (qq (c
          (unquote (f args))
          (unquote (c @cypher.macros.concat (r args)))
      ))
      (f args)
    )
  )

  (defmacro @cypher.macros.if-elif args
    ;; Nested if-else statements.
    ;
    ; Usage: (if-elif cond1 result1 cond2 result2 ... default)

    ;; Bram calls this "continued if" and has requested it
    ;; It's interesting that it actually is a generalization of `if`. It might
    ;; make sense to simply change `if` in the base language (which is implemented as
    ;; built-in macro) to allow for this.

    (if (r args)
      (qq (if (unquote (f args))
          (unquote (f (r args)))
          (unquote (c @cypher.macros.if-elif (r (r args))))
      ))
      (f args)
    )
  )

  (defmacro @cypher.macros.switch args
    ;; Nested if-else statements with con'ed statements.
    ;
    ; Usage: (switch (cond1 . result1) (cond2 . result2) ... default)
    ;; I think this is called `cond` in many lisps
    ;; not sure if we actually want `(cond1 . result1)` vs `(cond1 result1)`
    ;; would save the user typing a lot of dots for no real benefit

    (if (r args)
      (qq (if (unquote (f (f args)))
        (unquote (r (f args)))
        (unquote (c @cypher.macros.switch (r args)))
      ))
      (f args)
    )
  )

  ;; Exports

  (defmacro @cf.assert args (c @cypher.macros.assert args))
  (defmacro @cf.assert@debug args (c @cypher.macros.assert@debug args))
  (defmacro @cf.and args (c @cypher.macros.and args))
  (defmacro @cf.and@v2 args (c @cypher.macros.and@v2 args))
  (defmacro @cf.concat args (c @cypher.macros.concat args))
  (defmacro @cf.if-elif args (c @cypher.macros.if-elif args))
  (defmacro @cf.switch args (c @cypher.macros.switch args))
)
;; looks good