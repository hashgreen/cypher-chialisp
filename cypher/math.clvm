(
  ;; Unsigned subtraction.
  ;
  ; This function makes sure the result is at least zero.

  (defun-inline %cypher.math.unsigned-sub (minuend subtrahend)
    (if (> subtrahend minuend) (x) (- minuend subtrahend)))
  (defun cypher.math.unsigned-sub (minuend subtrahend)
    (%cypher.math.unsigned-sub minuend subtrahend))

  ;; Rounding to even or odd.

  (defun-inline %cypher.math.round-down-to-even (var)
    (if (logand var 1) (- var 1) var))
  (defun cypher.math.round-down-to-even (var)
    (%cypher.math.round-down-to-even var))

  (defun-inline %cypher.math.round-down-to-odd (var)
    (if (logand var 1) var (- var 1)))
  (defun cypher.math.round-down-to-odd (var)
    (%cypher.math.round-down-to-odd var))

  (defun-inline %cypher.math.round-up-to-even (var)
    (if (logand var 1) (+ var 1) var))
  (defun cypher.math.round-up-to-even (var)
    (%cypher.math.round-up-to-even var))

  (defun-inline %cypher.math.round-up-to-odd (var)
    (if (logand var 1) var (+ var 1)))
  (defun cypher.math.round-up-to-odd (var)
    (%cypher.math.round-up-to-odd var))

  ;; Division.
  ;
  ; The vanilla `/` operator has some unintended behavior, so we fall back to
  ; `divmod` operator.

  (defun-inline %cypher.math.div (numerator denominator)
    (f (divmod numerator denominator)))
  (defun cypher.math.div (numerator denominator)
    (%cypher.math.div numerator denominator))

  ;; Multiply var by the fraction (numerator / denominator).

  (defun-inline %cypher.math.mulfrac (var numerator denominator)
    (cypher.math.div (* var numerator) denominator))
  (defun cypher.math.mulfrac (var numerator denominator)
    (%cypher.math.mulfrac var numerator denominator))

  ;; Square root.

  (defun cypher.math.sqrt-loop-babylonian (var var1 var2)
    ;; Babylonian method for square root.
    ;
    ; See https://solidity-by-example.org/library/.

    (if (> var1 var2)
      (cypher.math.sqrt-loop-babylonian
        var var2 (cypher.math.div (+ (cypher.math.div var var2) var2) 2))
      var1
    )
  )

  (defun cypher.math.sqrt (var)
    (cypher.macros.switch
      ((> var 3) .
        (cypher.math.sqrt-loop-babylonian var var (+ (cypher.math.div var 2) 1)))
      ((> var 0) . 1)
      ((= var 0) . 0)
      (x)
    )
  )

  ;; Exports

  (defun-inline %cf.unsigned-sub (f . r) (%cypher.math.unsigned-sub f . r))
  (defun-inline cf.unsigned-sub (f . r) (cypher.math.unsigned-sub f . r))
  (defun-inline %cf.round-down-to-even (f . r) (%cypher.math.round-down-to-even f . r))
  (defun-inline cf.round-down-to-even (f . r) (cypher.math.round-down-to-even f . r))
  (defun-inline %cf.round-down-to-odd (f . r) (%cypher.math.round-down-to-odd f . r))
  (defun-inline cf.round-down-to-odd (f . r) (cypher.math.round-down-to-odd f . r))
  (defun-inline %cf.round-up-to-even (f . r) (%cypher.math.round-up-to-even f . r))
  (defun-inline cf.round-up-to-even (f . r) (cypher.math.round-up-to-even f . r))
  (defun-inline %cf.round-up-to-odd (f . r) (%cypher.math.round-up-to-odd f . r))
  (defun-inline cf.round-up-to-odd (f . r) (cypher.math.round-up-to-odd f . r))
  (defun-inline %cf.div (f . r) (%cypher.math.div f . r))
  (defun-inline cf.div (f . r) (cypher.math.div f . r))
  (defun-inline %cf.mulfrac (f . r) (%cypher.math.mulfrac f . r))
  (defun-inline cf.mulfrac (f . r) (cypher.math.mulfrac f . r))
  (defun-inline %cf.sqrt (f . r) (x "%cf.sqrt"))
  (defun-inline cf.sqrt (f . r) (cypher.math.sqrt f . r))
)
