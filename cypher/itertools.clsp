;;; Iterator processing library.
;
; Mocks the design of python itertools module.

(

  ;; utils

  (defun-inline --is-printable-char (char)
    (all (> char 31) (> 128 char))
  )

  (defun --is-printable-str.stager (str)
    (if str
      (all
        (--is-printable-str (/ str 256))
        (--is-printable-char (r (divmod str 256)))
      )
      1
    )
  )
  (defun --is-printable-str (str)
    (if (l str) 0 (--is-printable-str.stager str))
  )

  (defun-inline --apply (func args is-lambda)
    (a func (if is-lambda args (c func args)))
  )

  ;; chain

  (defun --cypher.itertools.chain (args_a args_b)
    ;; Flatten two args.
    ;
    ; Args:
    ;   args_a: list
    ;   args_b: Another list.
    ;
    ; Returns:
    ;   The flattend list.

    (if args_a
      (c
        (f args_a)
        (--cypher.itertools.chain (r args_a) args_b)
      )
      args_b
    )
  )

  (defmacro @cypher.itertools.chain args
    ;; Flatten multiple args, macro form.
    ;
    ; Args:
    ;   args: list of list to flatten.
    ;
    ; Returns:
    ;   The flattend list.

    (if args
      (qq
        (--cypher.itertools.chain
          (unquote (f args))
          (@cypher.itertools.chain . (unquote (r args)))
        )
      )
      cypher.constants.NIL
    )
  )
  (defun cypher.itertools.chain (args)
    ;; Flatten multiple args, function form.
    ;
    ; Args:
    ;   args: list of list to flatten.
    ;
    ; Returns:
    ;   The flattend list.

    (if args
      (--cypher.itertools.chain
        (f args)
        (cypher.itertools.chain (r args))
      )
      cypher.constants.NIL
    )
  )

  ;; map

  (defmacro --@cypher.itertools.map (func args is-lambda)
    ;; Apply map function to each element, macro form.
    ;
    ; Args:
    ;   func: function body.
    ;   args: list of arguments to apply func on.
    ;
    ; Returns:
    ;   A list of mapped results from func.

    (if args
      (qq
        (c
          (--apply
            (unquote func) (unquote (f args)) (unquote is-lambda)
          )
          (--@cypher.itertools.map
            (unquote func) (unquote (r args)) (unquote is-lambda)
          )
        )
      )
      cypher.constants.NIL
    )
  )
  (defmacro @cypher.itertools.map (func . args)
    (qq
      (--@cypher.itertools.map
        (unquote func) (unquote args) (unquote (l func))
      )
    )
  )

  (defun --cypher.itertools.map.stager (func args is-lambda)
    ;; Apply map function to each element, function form.
    ;
    ; Note that:
    ;   Chialisp's `(func args)` is secretly clvm's `func` application with
    ;   `func` at position 2 and `args` at position 3, so
    ;
    ;     (func args) => (a func (c func args))
    ;
    ;   For lambda functions, they don't send themselves to the function body, so
    ;
    ;     (func args) => (a func args)
    ;
    ; Args:
    ;   func: function.
    ;   args: list of arguments to apply func on.
    ;   is-lambda: whether func is a lambda function.
    ;
    ; Returns:
    ;   A list of mapped results from func.

    (if args
      (c
        (--apply func (f args) is-lambda)
        (--cypher.itertools.map.stager func (r args) is-lambda)
      )
      cypher.constants.NIL
    )
  )
  (defun --cypher.itertools.map (func args is-lambda)
    ; This is to "resolve" the symbol `func`, and if it is still is an atom,
    ;   it can be either still a symbol name, or a simple path as a function.

    (if (--is-printable-str func)
      (x
        (concat
          "`defun-inline` symbol does not work with `cf.map`! "
          "Please use `defun` of lambda functions instead."
        )
      )
      (--cypher.itertools.map.stager func args is-lambda)
    )
  )
  (defmacro cypher.itertools.map (func args)
    (qq
      (--cypher.itertools.map.stager
        (unquote func)
        (unquote args)
        (unquote (l func))
      )
    )
  )

  ;; reduce

  (defmacro --@cypher.itertools.reduce (func args initializer context is-lambda)
    ;; Apply reduce function to each element sequentially, macro form.
    ;
    ; Args:
    ;   func: function body.
    ;   args: list of arguments to apply reduction func on.
    ;   initializer: initial value for reduction.
    ;   context: global arguments for reduction.
    ;   is-lambda: whether func is a lambda function.
    ;
    ; Returns:
    ;   A reduced value.

    (if args
      (qq
        (--apply
          (unquote func)
          (c
            (unquote (f args))
            (c
              (--@cypher.itertools.reduce
                (unquote func) (unquote (r args)) (unquote initializer) (unquote context) (unquote is-lambda)
              )
              (unquote context)
            )
          )
          (unquote is-lambda)
        )
      )
      initializer
    )
  )
  (defmacro @cypher.itertools.reduce (func initializer context . args)
    (qq
      (--@cypher.itertools.reduce
        (unquote func) (unquote args) (unquote initializer) (unquote context) (unquote (l func))
      )
    )
  )

  (defun --cypher.itertools.reduce (func args initializer context is-lambda)
    ;; Apply reduce function to each element sequentially, function form.
    ;
    ; Args:
    ;   func: function that takes the arguments: (arg agg . context), where
    ;     arg: the current argument,
    ;     agg: the reduced value, and
    ;     context: the global arguments.
    ;
    ;   args: list of arguments to apply reduction func on.
    ;   initializer: initial value for reduction.
    ;   context: global arguments.
    ;   is-lambda: whether func is a lambda function.
    ;
    ; Returns:
    ;   A reduced value.

    (if args
      (--apply
        func
        (c
          (f args)
          (c
            (--cypher.itertools.reduce
              func (r args) initializer context is-lambda)
            context
          )
        )
        is-lambda
      )
      initializer
    )
  )
  (defmacro cypher.itertools.reduce (func initializer context args)
    (qq
      (--cypher.itertools.reduce
        (unquote func)
        (unquote args)
        (unquote initializer)
        (unquote context)
        (unquote (l func))
      )
    )
  )

  ;; Exports

  (defmacro @cf.chain args
    (c @cypher.itertools.chain args))
  (defmacro cf.chain args
    (c cypher.itertools.chain args))

  (defmacro @cf.map args
    (c @cypher.itertools.map args))
  (defmacro cf.map args
    (c cypher.itertools.map args))

  (defmacro @cf.reduce args
    (c @cypher.itertools.reduce args))
  (defmacro cf.reduce args
    (c cypher.itertools.reduce args))
)
