;;; Iterator processing library.
;
; Mocks the design of python itertools module.
;
; TODO: add the following functions:
;  - compress
;  - filter
;  - slice
;  - zip
;  - reverse
;  - filtermap

(
  ;; chain

  (defun --cypher.itertools.chain (args_a args_b)
    ;; Flatten two args.
    ;
    ; Args:
    ;   args_a: list
    ;   args_b: Another list.
    ;
    ; Returns:
    ;   The flattend list.

    (if args_a
      (c
        (f args_a)
        (--cypher.itertools.chain (r args_a) args_b)
      )
      args_b
    )
  )

  (defmacro @cypher.itertools.chain args
    ;; Flatten multiple args, macro form.
    ;
    ; Args:
    ;   args: list of list to flatten.
    ;
    ; Returns:
    ;   The flattend list.

    (if args
      (qq
        (--cypher.itertools.chain
          (unquote (f args))
          (@cypher.itertools.chain . (unquote (r args)))
        )
      )
      cypher.constants.NIL
    )
  )
  (defun cypher.itertools.chain (args)
    ;; Flatten multiple args, function form.
    ;
    ; Args:
    ;   args: list of list to flatten.
    ;
    ; Returns:
    ;   The flattend list.

    (if args
      (--cypher.itertools.chain
        (f args)
        (cypher.itertools.chain (r args))
      )
      cypher.constants.NIL
    )
  )

  ;; map

  (defmacro --@cypher.itertools.map (fn args is_lambda)
    (if args
      (qq
        (c
          (--@cypher.utils.apply
            (unquote fn) (unquote (f args)) (unquote is_lambda)
          )
          (--@cypher.itertools.map
            (unquote fn) (unquote (r args)) (unquote is_lambda)
          )
        )
      )
      cypher.constants.NIL
    )
  )
  (defmacro @cypher.itertools.map (fn . args)
    ;; Apply map function to each element, macro form.
    ;
    ; Args:
    ;   func: function body.
    ;   args: list of arguments to apply func on.
    ;
    ; Returns:
    ;   A list of mapped results from func.

    (qq
      (--@cypher.itertools.map
        (unquote fn) (unquote args) (unquote (l fn))
      )
    )
  )

  (defun --cypher.itertools.map.stager (fn args is_lambda)
    (if args
      (c
        (--@cypher.utils.apply fn (f args) is_lambda)
        (--cypher.itertools.map.stager fn (r args) is_lambda)
      )
      cypher.constants.NIL
    )
  )
  (defun --cypher.itertools.map (fn args is_lambda)
    ; This is to "resolve" the symbol `func`, and if it is still is an atom,
    ;   it can be either still a symbol name, or a simple path as a function.

    (if (--cypher.utils.is-printable-str fn)
      (x
        (concat
          "`defun-inline` symbol does not work with `cf.map`! "
          "Please use `defun` of lambda functions instead."
        )
      )
      (--cypher.itertools.map.stager fn args is_lambda)
    )
  )
  (defmacro cypher.itertools.map (fn args)
    ;; Apply map function to each element, function form.
    ;
    ; Note that:
    ;   Chialisp's `(func args)` is secretly clvm's `func` application with
    ;   `func` at position 2 and `args` at position 3, so
    ;
    ;     (func args) => (a func (c func args))
    ;
    ;   For lambda functions, they don't send themselves to the function body, so
    ;
    ;     (func args) => (a func args)
    ;
    ; Args:
    ;   func: function.
    ;   args: list of arguments to apply func on.
    ;
    ; Returns:
    ;   A list of mapped results from func.

    (qq
      (--cypher.itertools.map.stager
        (unquote fn)
        (unquote args)
        (unquote (l fn))
      )
    )
  )

  ;; reduce

  (defmacro --@cypher.itertools.reduce (fn args initializer context is_lambda)
    (if args
      (qq
        (--@cypher.utils.apply
          (unquote fn)
          (@cypher.utils.prelist
            (unquote (f args))
            (--@cypher.itertools.reduce
              (unquote fn) (unquote (r args)) (unquote initializer) (unquote context) (unquote is_lambda)
            )
            (unquote context)
          )
          (unquote is_lambda)
        )
      )
      initializer
    )
  )
  (defmacro @cypher.itertools.reduce (fn initializer context . args)
    ;; Apply reduce function to each element sequentially, macro form.
    ;
    ; Args:
    ;   func: function body.
    ;   initializer: initial value for reduction.
    ;   context: global arguments for reduction.
    ;   args: list of arguments to apply reduction func on.
    ;
    ; Returns:
    ;   A reduced value.

    (qq
      (--@cypher.itertools.reduce
        (unquote fn) (unquote args) (unquote initializer) (unquote context) (unquote (l fn))
      )
    )
  )

  (defun --cypher.itertools.reduce (fn args initializer context is_lambda)
    ; `fn` should be concrete functions, not symbols, while `is_lambda` hints
    ; the origin of `fn`
    (if args
      (--@cypher.utils.apply
        fn
        (@cypher.utils.prelist
          (f args)
          (--cypher.itertools.reduce
            fn (r args) initializer context is_lambda
          )
          context
        )
        is_lambda
      )
      initializer
    )
  )
  (defmacro cypher.itertools.reduce (fn initializer context args)
    ;; Apply reduce function to each element sequentially, function form.
    ;
    ; Args:
    ;   func: function that takes the arguments: (arg agg . context), where
    ;     arg: the current argument,
    ;     agg: the reduced value, and
    ;     context: the global arguments.
    ;
    ;   initializer: initial value for reduction.
    ;   context: global arguments.
    ;   args: list of arguments to apply reduction func on.
    ;
    ; Returns:
    ;   A reduced value.

    (qq
      (--cypher.itertools.reduce
        (unquote fn)
        (unquote args)
        (unquote initializer)
        (unquote context)
        (unquote (l fn))
      )
    )
  )

  ;; Exports

  (defmacro @cf.chain args
    (c @cypher.itertools.chain args))
  (defmacro cf.chain args
    (c cypher.itertools.chain args))

  (defmacro @cf.map args
    (c @cypher.itertools.map args))
  (defmacro cf.map args
    (c cypher.itertools.map args))

  (defmacro @cf.reduce args
    (c @cypher.itertools.reduce args))
  (defmacro cf.reduce args
    (c cypher.itertools.reduce args))
)
