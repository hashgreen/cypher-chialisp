;;; Math functions.

(
  ;; Unary operators.

  (defun-inline @cypher.math.abs (var)
    ;; Absolute value.
    ;
    ; Args:
    ;   var: The number to take the absolute value of.
    ;
    ; Returns:
    ;   An integer, the absolute value of `var`.

    (if (> var 0) var (- 0 var))
  )
  (defun cypher.math.abs (var)
    (@cypher.math.abs var))

  (defun-inline @cypher.math.round-down-to-even (var)
    ;; Round down to the nearest even number.
    ;
    ; Args:
    ;   var: The number to round.
    ;
    ; Returns:
    ;   An integer, the result of the rounding.

    (if (logand var 1) (- var 1) var)
  )
  (defun cypher.math.round-down-to-even (var)
    (@cypher.math.round-down-to-even var))

  (defun-inline @cypher.math.round-down-to-odd (var)
    ;; Round down to the nearest odd number.
    ;
    ; Args:
    ;   var: The number to round.
    ;
    ; Returns:
    ;   An integer, the result of the rounding.

    (if (logand var 1) var (- var 1))
  )
  (defun cypher.math.round-down-to-odd (var)
    (@cypher.math.round-down-to-odd var))

  (defun-inline @cypher.math.round-up-to-even (var)
    ;; Round up to the nearest even number.
    ;
    ; Args:
    ;   var: The number to round.
    ;
    ; Returns:
    ;   An integer, the result of the rounding.

    (if (logand var 1) (+ var 1) var)
  )
  (defun cypher.math.round-up-to-even (var)
    (@cypher.math.round-up-to-even var))

  (defun-inline @cypher.math.round-up-to-odd (var)
    ;; Round up to the nearest odd number.
    ;
    ; Args:
    ;   var: The number to round.
    ;
    ; Returns:
    ;   An integer, the result of the rounding.

    (if (logand var 1) var (+ var 1));
  )
  (defun cypher.math.round-up-to-odd (var)
    (@cypher.math.round-up-to-odd var))

  (defun --cypher.math.sqrt-loop-babylonian (var var1 var2)
    ;; Babylonian method for square root.
    ;
    ; See https://solidity-by-example.org/library/.
    ;
    ; Args:
    ;   var: The number to take the square root of.
    ;   var1: The previous guess.
    ;   var2: The current guess.
    ;
    ; Returns:
    ;   An integer, the result of the square root.

    (if (> var1 var2)
      (--cypher.math.sqrt-loop-babylonian
        var
        var2
        (ash (+ (@cypher.math.div var var2) var2) -1)
      )
      var1
    )
  )

  (defun-inline @cypher.math.sqrt (var)
    ;; Square root.
    ;
    ; Args:
    ;   var: The number to take the square root of.
    ;
    ; Returns:
    ;   An integer, the result of the square root.

    (@cypher.utils.if
      (> var 3)
      (--cypher.math.sqrt-loop-babylonian
        var
        var
        (+ (ash var -1) 1)
      )
      (> var 0) 1
      (= var 0) 0
      (x)
    )
  )
  (defun cypher.math.sqrt (var)
    (@cypher.math.sqrt var))

  (defun --cypher.math.str (var decimals)
    (@cypher.utils.if
      (> decimals 0)
      (concat
        (--cypher.math.str (@cypher.math.div var 10) (- decimals 1))
        (+ 48 (r (divmod var 10)))
      )
      ;
      (= decimals 0)
      (concat
        (--cypher.math.str (@cypher.math.div var 10) (- decimals 1))
        (+ 48 (r (divmod var 10)))
        "."
      )
      ;
      (all (= decimals -1) (> var 0))
      (concat
        (--cypher.math.str (@cypher.math.div var 10) -1)
        (+ 48 (r (divmod var 10)))
      )
      ;
      ""
    )
  )

  (defun-inline @cypher.math.str (var decimals)
    ;; Convert var to string.
    ;
    ; Args:
    ;   var: integer to convert.
    ;   decimals: decimal places. -1 to disable printing decimal point.
    ;
    ; Returns:
    ;   The string representation of `var`.

    (if
      (all (= var 0) (= decimals -1))
      "0"
      (concat
        (if (> 0 var) "-" "")
        (--cypher.math.str (@cypher.math.abs var) decimals)
      )
    )
  )
  (defun cypher.math.str (var decimals)
    (@cypher.math.str var decimals))

  ;; Binary operators.

  (defun-inline @cypher.math.add (augend addend)
    ;; Addition.
    ;
    ; Args:
    ;   augend: The augend.
    ;   addend: The addend.
    ;
    ; Returns:
    ;   An integer, the result of the addition.

    (+ augend addend)
  )
  (defun cypher.math.add (augend addend)
    (@cypher.math.add augend addend))

  (defun-inline @cypher.math.sub (minuend subtrahend)
    ;; Subtraction.
    ;
    ; Args:
    ;   minuend: The minuend.
    ;   subtrahend: The subtrahend.
    ;
    ; Returns:
    ;   An integer, the result of the subtraction.

    (- minuend subtrahend)
  )
  (defun cypher.math.sub (minuend subtrahend)
    (@cypher.math.sub minuend subtrahend))

  (defun-inline @cypher.math.unsigned-sub (minuend subtrahend)
    ;; Unsigned subtraction.
    ;
    ; Args:
    ;   minuend: The minuend.
    ;   subtrahend: The subtrahend.
    ;
    ; Returns:
    ;   An integer, the result of the unsigned subtraction.

    (if (> subtrahend minuend) (x) (- minuend subtrahend))
  )
  (defun cypher.math.unsigned-sub (minuend subtrahend)
    (@cypher.math.unsigned-sub minuend subtrahend))

  (defun-inline @cypher.math.div@unsafe (numer denom)
    ;; Division using the vanilla `/` operator.
    ;
    ; Args:
    ;   numer: The numerator.
    ;   denom: The denominator.
    ;
    ; Returns:
    ;   An integer, the result of the division.

    (/ numer denom)
  )
  (defun cypher.math.div@unsafe (numer denom)
    (@cypher.math.div@unsafe numer denom))

  (defun-inline @cypher.math.div (numer denom)
    ;; Division.
    ;
    ; The vanilla `/` operator has some unintended behavior, so we fall back to
    ; `divmod` operator.
    ;
    ; Args:
    ;   numer: The numerator.
    ;   denom: The denominator.
    ;
    ; Returns:
    ;   An integer, the result of the division.

    (f (divmod numer denom))
  )
  (defun cypher.math.div (numer denom)
    (@cypher.math.div numer denom))

  (defun --cypher.math.pow (base exponent)

    (if (> exponent 0)
      (* base (--cypher.math.pow base (- exponent 1)))
      1
    )
  )
  (defun-inline @cypher.math.pow (base exponent)
    ;; Naive power.
    ;
    ; Args:
    ;   base: The base.
    ;   exponent: The exponent.
    ;
    ; Returns:
    ;   An integer, the result of the power.

    (@cypher.utils.assert
      (not (> 0 exponent))
      (--cypher.math.pow base exponent)
    )
  )
  (defun cypher.math.pow (base exponent)
    (@cypher.math.pow base exponent))

  ;; Binary operators with other objects.

  (defun-inline @cypher.math.mul-frac (var frac)
    ;; Multiply a number by a fraction.
    ;
    ; Args:
    ;   var: The number.
    ;   frac: A `Frac` object.
    ;
    ; Returns:
    ;   An integer, the result of the multiplication.

    (@cypher.math.div
      (*
        var
        (@cypher.fracmath.Frac.get-numerator frac)
      )
      (@cypher.fracmath.Frac.get-denominator frac)
    )
  )
  (defun cypher.math.mul-frac (var frac)
    (@cypher.math.mul-frac var frac))

  ;; Exports

  (defmacro @cf.abs args
    (c @cypher.math.abs args))
  (defmacro cf.abs args
    (c cypher.math.abs args))
  (defmacro @cf.round-down-to-even args
    (c @cypher.math.round-down-to-even args))
  (defmacro cf.round-down-to-even args
    (c cypher.math.round-down-to-even args))
  (defmacro @cf.round-down-to-odd args
    (c @cypher.math.round-down-to-odd args))
  (defmacro cf.round-down-to-odd args
    (c cypher.math.round-down-to-odd args))
  (defmacro @cf.round-up-to-even args
    (c @cypher.math.round-up-to-even args))
  (defmacro cf.round-up-to-even args
    (c cypher.math.round-up-to-even args))
  (defmacro @cf.round-up-to-odd args
    (c @cypher.math.round-up-to-odd args))
  (defmacro cf.round-up-to-odd args
    (c cypher.math.round-up-to-odd args))
  (defmacro @cf.sqrt args
    (c @cypher.math.sqrt args))
  (defmacro cf.sqrt args
    (c cypher.math.sqrt args))
  (defmacro @cf.str args
    (c @cypher.math.str args))
  (defmacro cf.str args
    (c cypher.math.str args))

  (defmacro @cf.add args
    (c @cypher.math.add args))
  (defmacro cf.add args
    (c cypher.math.add args))
  (defmacro @cf.sub args
    (c @cypher.math.sub args))
  (defmacro @cf.unsigned-sub args
    (c @cypher.math.unsigned-sub args))
  (defmacro cf.unsigned-sub args
    (c cypher.math.unsigned-sub args))
  (defmacro @cf.div@unsafe args
    (c @cypher.math.div@unsafe args))
  (defmacro cf.div@unsafe args
    (c cypher.math.div@unsafe args))
  (defmacro @cf.div args
    (c @cypher.math.div args))
  (defmacro cf.div args
    (c cypher.math.div args))
  (defmacro @cf.pow args
    (c @cypher.math.pow args))
  (defmacro cf.pow args
    (c cypher.math.pow args))
  (defmacro @cf.mul-frac args
    (c @cypher.math.mul-frac args))
  (defmacro cf.mul-frac args
    (c cypher.math.mul-frac args))
)
